
Cop_value_prim with value 2

---

number_comparable ==> ===
---


enter run_expr / exit run_expr

----

option_case

elim bool_eq


no event on coercions or stdlib

-----

coercions:
Coercion prim_bool : bool >-> prim.
Coercion prim_number : JsNumber.number >-> prim.
Coercion prim_string : string >-> prim.
Coercion value_prim : prim >-> value.
Coercion object_loc_prealloc : prealloc >-> object_loc.
Coercion value_object : object_loc >-> value.

Coercion attributes_data_of : attributes_data >-> attributes.
Coercion attributes_accessor_of : attributes_accessor >-> attributes.
Coercion full_descriptor_some : attributes >-> full_descriptor.
Coercion env_record_decl : decl_env_record >-> env_record.
Coercion resvalue_value : value >-> resvalue.
Coercion resvalue_ref : ref >-> resvalue.
Coercion res_ref (r : ref) := res_intro restype_normal r label_empty.
Coercion res_val (v : value) := res_intro restype_normal v label_empty.
Coercion res_normal rv := res_intro restype_normal rv label_empty.



---

inline not

----




inline let object_loc_comparable x y =
 et al
-----

   Coq_out_ter (s1,x) ---> x

	 res_ref r  -->  r
	 res_val v -->  v
	 res_normal rv -->  rv

----




let%if_spec (s,x) = expr in cont
becomes
   if_spec expr (fun s x -> cont) 

and in pseudo:
  Let%spec x = expr in
  cont


------------


  Let (x,y) = ...
   

------------

            return (
              if_run(
                convert_twice_string(Coq_value_prim(w1), Coq_value_prim(w2)),
                function (ss) {
                  var s3 = ss[0], s4 = ss[1];
                  return (
                    res_out(
                      Coq_out_ter(s2,
                        res_val(
                          Coq_value_prim(Coq_prim_string(strappend(s3, s4)))))));
                }));




          let%run (s3,s4) = convert_twice_string(Coq_value_prim(w1), Coq_value_prim(w2)) in
              if_run(
                ,
                function (ss) {
                  var s3 = ss[0], s4 = ss[1];
                  return (
                    res_out(
                      Coq_out_ter(s2,
                        res_val(
                          Coq_value_prim(Coq_prim_string(strappend(s3, s4)))))));
                }));




--------------

  switch (v2.tag) {
	 case "Coq_value_prim":
		var p = v2.value;
		return (run_error(Coq_native_error_type()));
	 case "Coq_value_object":
		var l = v2.value;
		return (...);

BECOMES IN PSEUDO

  match (v2) {
	 case Coq_value_prim(p) :
		return (run_error(Coq_native_error_type()));
	 case Coq_value_object(l):
	   return (...);













(** val object_write : state -> object_loc -> coq_object -> state **)
=> on pourrait faire
(** val object_write : state -> object_loc -> coq_object -> unit*state **)


 -----------

    let_binding (fun s0 ->
      if_value (def s0 l) (fun s_2 v ->
        if spec_function_get_error_case_dec s_2 x v
        then run_error s_2 Coq_native_error_type
        else res_ter s_2 (res_val v))) (fun function0 -> ...)
  
 -----------
   spec_function_get_error_case_dec (@pure)

	let function0 = fun () -> (* implicity bind s0 *)
		 let%value v = (def l) in     (* implicitly from s0 to s_2 *)
		 let%ter_ro b = spec_function_get_error_case_dec x v in	 (* implicy pass s_2 en read-only *)
       if b
         then run_error Coq_native_error_type  (* on s2 implicitly *)
         else return_val v)) (* res on s2 implicitly *) (* where  return_val v = res_ter (res_val v) *)
   in ...


 -----------

state as last arg

 -----------
TODO inliner:
	let if_any_or_throw w k1 k2 =
	let if_success_or_return w k1 k2 =

 -----------
TODO 

	let if_success_state rv w k =
	=> inliner if_ter 
	  et nommer la fonction à l'intérieur, qui est stateless

 -----------

inline or_decidable
 and all of libreflect


 ----
 rename decl_env_record_pickable_option into
 decl_env_record_option
----------

remove Coq_value_prim
----

TODO: regexp pour cacher les %s et %c
----


(* TODO: one day
    let%spec v1 = run_expr_get_value e1 in
    let%spec v2 = run_expr_get_value e2 in
    run_binary_op op v1 v2
*)


=========================================================

list.rev on ctx

display quotes 1717

reach condition



=========================================================
CURRENT TODO


*) Thomas: more testing

*) Alan: proof read JSNumber

*) Arthur: inline let_binding

*) Alan/Thomas: test "eval"
    Still need to implement parsing with a given strictness

*) ? 
  update the ML code for: type_compare mutability_compare prim_compare 
  (for prim_compare, we should be able to match on pairs of arguments, with a catch-all)

*) 
   - move prim_compare and value_compare to JsInterpreter because it is interesting and should be logged
   - move same_value_dec from jscommonaux 

*) See if we can inline the "%able" functions, e.g. string_comparable



*) [thomas]
- bigger test262 testing.
- Flag to force esprima to parse in strict mode

*) LATER: remove useless files such as LibReflect LibString etc...


*) [thomas]
- put online the tool on the jscert website
	  - make sure to describe the supported features 
	    (ecma5 minus for-in and a few other things)
     - explain that currently JS files are generated
	    from ML files and thus should not be edited,
		 although this might change in the future.
    - assembly.js should have a header
       to tell people not to use this file


*) Arthur: full display	of heap information
	  add a "+details" button 
	  to show additional information about an object, like the
	  getter and setter methods, and also for each field we need
	  to see additional information like enumerable/configurable...


*) Arthur: search by predicate in the trace
	- remove the "with (obj)" hack that is currently there
	- introduce functions
	   - INTERP_RAW("x") : returns the value bound to "x" in the
		  current context, by looking up the linked list of arrays
		- PROG_RAW("x") : returns the value bound to "x" in the
		  environment, using the prototype chain resolution function
		- JSOF(v) : lift the encoding of a JS value to the corresponding JS value
		- INTERP_VAL("x") = JSOF(INTERP_RAW("x"))
		- PROG_VAL("x") = JSOF(PROG_RAW("x"))


*) Alan:
  There is one place where we compute a "substring" in the code;
  need to check whether the argument is always nonnegative.


*) Coq extraction has generated cases in the order of the definition
  of the constructors in the inductive definition; this is not the
  same order as in the original coq files; we should put back in
  the right order, i'm afraid we need to do this by hand.





=========================================================
LATER-- OPTIMIZATIONS

- The representation of the heap could be optimized by
  having "remove" nodes in the list describing a heap,
  this would avoid filtering through the heap in O(n).

- Optimize heap representations using trees, to improve
  lookups from O(n) to O(log n).

- Only introduce logging instructions in files for which
  they are going to be used.



=========================================================
LATER-- FOR A BETTER ML TO JS TRANSLATION

- Js_of_ast prevent use of "tag" or "type" as object field name 

- generate "type: " in smart constructors [optional until display is needed]

- Reactivate the generation of the lines of the form:
	  default: throw "No matching case for switch";
  by having js_of_pattern return an additional boolean 
  indicating whether there was a default case or not.
  This is needed to detect bugs in the spec where the
  switch are missing useful cases.


=========================================================
TRICK-- HERE IS HOW TO PRINT BROWSER STACK SIZE LIMIT:

	in the console, execute:

		var i=0;
		function inc() {
			 i++;
			 inc();
		}
		inc();

	then print value of "i".

=========================================================
