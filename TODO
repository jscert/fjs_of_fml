
- update the code that translates esprima syntax to recognize
  "use strict" directives, which come as first statement of
  a body, in hte form of a raw expression of raw type "use script".
  => TODO: look for code that already does this for esprima.







=========================================================


LATER
- cases seem to be in reversed order, check and fix
   => corriger à la main le jour où on s'amuse à relire le code.
	=> order in pattern matching extraction seems to follow
	   order from the definition of the inductive type,
		instead of the order of the code.

LATER
- untab closing bracket for fun def
  => later maybe



- Choose a small example

    var x = 3;
    x = 4;
    if (x === 4) {
      while (true) {}
    }

- write a JS function that takes an esprima AST as input (sub-language for the
  moment) that generates an AST in our syntax (encoded of concrete types):
    { type : constructor; label0 : value ; … }
  this should remember locations

- edit JsSyntax.ml to put readable labels

- write a driver in JS
  - take a program in the text area
  - parse to esprima
  - translate to our syntax
  - call JsInterpreter.js using the correct function (see run_js.ml)

- translate stdlib.ml into stdlib.js

- correct the Makefile to make sure we do not generate everything all the time



- => binder qq part vers une comparaison --- dans un fichier js
  _compare_JsSyntax_native_error
  _compare_JsSyntax_prealloc



==========

TODO: demo of double clicking goes to the right page in ecma in english

TODO: interpretation of comparison function in the search by "predicate"
   might want to automatically "lift" basic values to their encoding
	(unless some box is checked to prevent this behavior)

	example:  "x == 3"  means:
	"similar(x, { type: "value", tag: "value_prim", value: { type: "prim", tag: "float", value: 3.0 } })".

	where similar is a recursive structural comparison function (not going through the heap)


==========
