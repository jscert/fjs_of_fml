(** val object_write : state -> object_loc -> coq_object -> state **)
=> on pourrait faire
(** val object_write : state -> object_loc -> coq_object -> unit*state **)


 -----------

    let_binding (fun s0 ->
      if_value (def s0 l) (fun s_2 v ->
        if spec_function_get_error_case_dec s_2 x v
        then run_error s_2 Coq_native_error_type
        else res_ter s_2 (res_val v))) (fun function0 -> ...)
  
 -----------
   spec_function_get_error_case_dec (@pure)

	let function0 = fun () -> (* implicity bind s0 *)
		 let%value v = (def l) in     (* implicitly from s0 to s_2 *)
		 let%ter_ro b = spec_function_get_error_case_dec x v in	 (* implicy pass s_2 en read-only *)
       if b
         then run_error Coq_native_error_type  (* on s2 implicitly *)
         else return_val v)) (* res on s2 implicitly *) (* where  return_val v = res_ter (res_val v) *)
   in ...


 -----------

state as last arg

 -----------
TODO inliner:
	let if_any_or_throw w k1 k2 =
	let if_success_or_return w k1 k2 =

 -----------
TODO 

	let if_success_state rv w k =
	=> inliner if_ter 
	  et nommer la fonction à l'intérieur, qui est stateless

 -----------

inline or_decidable
 and all of libreflect


 ----
 rename decl_env_record_pickable_option into
 decl_env_record_option
----------

remove Coq_value_prim
----

(* TODO: one day
    let%spec v1 = run_expr_get_value e1 in
    let%spec v2 = run_expr_get_value e2 in
    run_binary_op op v1 v2
*)


=========================================================

list.rev on ctx

display quotes 1717

reach condition



=========================================================
CURRENT TODO


*) Thomas: more testing

*) Alan: proof read JSNumber

*) Arthur: inline let_binding

*) Alan/Thomas: test "eval"
    Still need to implement parsing with a given strictness

*) ? 
  update the ML code for: type_compare mutability_compare prim_compare 
  (for prim_compare, we should be able to match on pairs of arguments, with a catch-all)

*) 
   - move prim_compare and value_compare to JsInterpreter because it is interesting and should be logged
   - move same_value_dec from jscommonaux 

*) See if we can inline the "%able" functions, e.g. string_comparable



*) [thomas]
- bigger test262 testing.
- Flag to force esprima to parse in strict mode

*) LATER: remove useless files such as LibReflect LibString etc...


*) [thomas]
- put online the tool on the jscert website
	  - make sure to describe the supported features 
	    (ecma5 minus for-in and a few other things)
     - explain that currently JS files are generated
	    from ML files and thus should not be edited,
		 although this might change in the future.
    - assembly.js should have a header
       to tell people not to use this file


*) Arthur: full display	of heap information
	  add a "+details" button 
	  to show additional information about an object, like the
	  getter and setter methods, and also for each field we need
	  to see additional information like enumerable/configurable...


*) Arthur: search by predicate in the trace
	- remove the "with (obj)" hack that is currently there
	- introduce functions
	   - INTERP_RAW("x") : returns the value bound to "x" in the
		  current context, by looking up the linked list of arrays
		- PROG_RAW("x") : returns the value bound to "x" in the
		  environment, using the prototype chain resolution function
		- JSOF(v) : lift the encoding of a JS value to the corresponding JS value
		- INTERP_VAL("x") = JSOF(INTERP_RAW("x"))
		- PROG_VAL("x") = JSOF(PROG_RAW("x"))


*) Alan:
  There is one place where we compute a "substring" in the code;
  need to check whether the argument is always nonnegative.


*) Coq extraction has generated cases in the order of the definition
  of the constructors in the inductive definition; this is not the
  same order as in the original coq files; we should put back in
  the right order, i'm afraid we need to do this by hand.





=========================================================
LATER-- OPTIMIZATIONS

- The representation of the heap could be optimized by
  having "remove" nodes in the list describing a heap,
  this would avoid filtering through the heap in O(n).

- Optimize heap representations using trees, to improve
  lookups from O(n) to O(log n).

- Only introduce logging instructions in files for which
  they are going to be used.



=========================================================
LATER-- FOR A BETTER ML TO JS TRANSLATION

- Js_of_ast prevent use of "tag" or "type" as object field name 

- generate "type: " in smart constructors [optional until display is needed]

- Reactivate the generation of the lines of the form:
	  default: throw "No matching case for switch";
  by having js_of_pattern return an additional boolean 
  indicating whether there was a default case or not.
  This is needed to detect bugs in the spec where the
  switch are missing useful cases.


=========================================================
TRICK-- HERE IS HOW TO PRINT BROWSER STACK SIZE LIMIT:

	in the console, execute:

		var i=0;
		function inc() {
			 i++;
			 inc();
		}
		inc();

	then print value of "i".

=========================================================
